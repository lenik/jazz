<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v2004 rel. 3 U (http://www.xmlspy.com) by CPU007 (STUPYNOMAGIC) -->
<xs:schema targetNamespace="http://www.bodz.net/xml/draft/lang/tix" xmlns:xaa="http://www.bodz.net/xml/draft/xaa/section-support" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ti="http://www.bodz.net/xml/draft/lang/tix" elementFormDefault="qualified" attributeFormDefault="unqualified">
    <xs:import namespace="http://www.bodz.net/xml/draft/xaa/section-support" schemaLocation="http://www.bodz.net/xml/draft/xaa/section-support.xsd"/>
    <!--========== FACADE ==========-->
    <xs:element name="latix">
        <xs:annotation>
            <xs:documentation>Think-infinite XML (see also Tis: Think-infinite script)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="xaa:section-extendable-base">
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="namespace" type="ti:st-namespace"/>
                    </xs:choice>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!--========== BASE STRUCTURE ==========-->
    <xs:complexType name="base-code-unit">
        <xs:attribute name="id" type="xs:string" use="optional"/>
    </xs:complexType>
    <xs:complexType name="base-execution">
        <xs:annotation>
            <xs:documentation>Execution elements have rtl attribute. </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-code-unit">
                <xs:attribute name="rtl" type="xs:integer" use="optional" default="0"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-expression">
        <xs:annotation>
            <xs:documentation>Expression elements carry meaningful value. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ti:grp-value"/>
            <xs:group ref="ti:grp-operator"/>
            <xs:group ref="ti:grp-function"/>
        </xs:choice>
        <xs:attribute name="id" type="xs:string" use="optional"/>
    </xs:complexType>
    <!--========== OPERATOR ==========-->
    <xs:complexType name="base-operator" mixed="true">
        <xs:annotation>
            <xs:documentation>Execution unit

If the (mixed-) content isn't empty, then it will be splited by space into operands. 

The operand subelement can overload the operands of mixed-contents. </xs:documentation>
        </xs:annotation>
        <xs:complexContent mixed="true">
            <xs:extension base="ti:base-execution"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-operator-unary">
        <xs:annotation>
            <xs:documentation>Unary operator</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-operator">
                <xs:sequence minOccurs="0">
                    <xs:element ref="ti:operand"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-operator-binary-left">
        <xs:annotation>
            <xs:documentation>Binary operator with left-association</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-operator">
                <xs:sequence minOccurs="0">
                    <xs:element ref="ti:operand" minOccurs="2" maxOccurs="unbounded"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-operator-binary-right">
        <xs:annotation>
            <xs:documentation>Binary operator with right-association</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-operator">
                <xs:sequence minOccurs="0">
                    <xs:element ref="ti:operand" minOccurs="2" maxOccurs="unbounded"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-operator-ternary">
        <xs:annotation>
            <xs:documentation>Ternary operator</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-operator">
                <xs:sequence minOccurs="0">
                    <xs:element ref="ti:operand" minOccurs="3" maxOccurs="3"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-operator-variable">
        <xs:annotation>
            <xs:documentation>Variable-argument operator</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-operator">
                <xs:sequence minOccurs="0">
                    <xs:element ref="ti:operand" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:group name="grp-operator-bit">
        <xs:annotation>
            <xs:documentation>Bit operators</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="bit-not" type="ti:base-operator-unary"/>
            <xs:element name="bit-neg" type="ti:base-operator-unary"/>
            <xs:element name="bit-and" type="ti:base-operator-binary-left"/>
            <xs:element name="bit-or" type="ti:base-operator-binary-left"/>
            <xs:element name="bit-xor" type="ti:base-operator-binary-left"/>
            <xs:element name="bit-shift">
                <xs:annotation>
                    <xs:documentation>shift: number of levels to shift, positive for right, negtive for left. 

looped: looped-shift

signed: don't shift MSB</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-binary-left">
                            <xs:attribute name="looped" type="xs:boolean" use="optional" default="false"/>
                            <xs:attribute name="signed" type="xs:boolean" use="optional" default="false"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="bit-count">
                <xs:annotation>
                    <xs:documentation>character: 0, [1]</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-unary">
                            <xs:attribute name="character" type="xs:string" use="optional" default="1"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="bit-count-prefix">
                <xs:annotation>
                    <xs:documentation>character: 0, 1

from: [left], right</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-unary">
                            <xs:attribute name="character" type="xs:string" use="optional" default="1"/>
                            <xs:attribute name="from" type="xs:string" use="optional" default="left"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-operator-arithmatic">
        <xs:annotation>
            <xs:documentation>Arithmatic operators</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="add" type="ti:base-operator-binary-left"/>
            <xs:element name="subtract" type="ti:base-operator-binary-left"/>
            <xs:element name="multiply" type="ti:base-operator-binary-left"/>
            <xs:element name="divide" type="ti:base-operator-binary-left"/>
            <xs:element name="power" type="ti:base-operator-binary-right"/>
            <xs:element name="increase" type="ti:base-operator-unary"/>
            <xs:element name="decrease" type="ti:base-operator-unary"/>
        </xs:choice>
    </xs:group>
    <xs:attributeGroup name="atg-operator-logic">
        <xs:attribute name="true" type="xs:integer" use="optional" default="1"/>
        <xs:attribute name="short" type="xs:boolean" use="optional" default="false"/>
    </xs:attributeGroup>
    <xs:group name="grp-operator-logic">
        <xs:annotation>
            <xs:documentation>Logical operators</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="is-all">
                <xs:annotation>
                    <xs:documentation>logic-and</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-variable">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is-any">
                <xs:annotation>
                    <xs:documentation>logic-and</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-variable">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is-only">
                <xs:annotation>
                    <xs:documentation>logic-xor only when binary-operator</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-variable">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is">
                <xs:annotation>
                    <xs:documentation>simple test</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-unary">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is-not">
                <xs:annotation>
                    <xs:documentation>logic-not</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-unary">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is-equal">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-binary-left">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is-greater">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-binary-left">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="is-less">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-binary-left">
                            <xs:attributeGroup ref="ti:atg-operator-logic"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-operator-datatype">
        <xs:annotation>
            <xs:documentation>Data-type related operators</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="size-of" type="ti:base-operator-unary"/>
            <xs:element name="address-of" type="ti:base-operator-unary"/>
            <xs:element name="value-at" type="ti:base-operator-unary"/>
            <xs:element name="member-of">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-operator-unary">
                            <xs:attribute name="select" type="xs:string" use="optional"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="reinterpret-cast" type="ti:base-operator-unary"/>
            <xs:element name="static-cast" type="ti:base-operator-unary"/>
            <xs:element name="dynamic-cast" type="ti:base-operator-unary"/>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-operator-misc">
        <xs:annotation>
            <xs:documentation>Other operators</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="iif" type="ti:base-operator-ternary"/>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-operator">
        <xs:annotation>
            <xs:documentation>arithmatic, type-cast, ref/deref, etc.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="ti:grp-operator-bit"/>
            <xs:group ref="ti:grp-operator-arithmatic"/>
            <xs:group ref="ti:grp-operator-logic"/>
            <xs:group ref="ti:grp-operator-datatype"/>
            <xs:group ref="ti:grp-operator-misc"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="base-operand">
        <xs:annotation>
            <xs:documentation>An operand is lv-enabled expression. </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-expression">
                <xs:attribute name="left-value" type="xs:boolean" use="optional" default="false"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:element name="operand" type="ti:base-operand">
        <xs:annotation>
            <xs:documentation>Expression Operand</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!--STATEMENT - FUNCTION-->
    <xs:group name="grp-function">
        <xs:annotation>
            <xs:documentation>assignment, function-call</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="call-function" type="ti:base-operator"/>
            <xs:element name="lv-assign"/>
            <xs:element name="throw"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="base-function-impl">
        <xs:group ref="ti:grp-any"/>
        <xs:attribute name="layer" type="xs:string" use="optional" default="main"/>
        <xs:attribute name="extends-at" use="optional" default="after">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="before"/>
                    <xs:enumeration value="after"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="base-function">
        <xs:annotation>
            <xs:documentation>The storage-traits of a function is specified uncommonly. </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ti:base-code-unit">
                <xs:sequence>
                    <xs:element name="in" type="ti:base-element" minOccurs="0"/>
                    <xs:element name="out" type="ti:base-element" minOccurs="0"/>
                    <xs:element name="throws" type="ti:base-type-use" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="implement" type="ti:base-function-impl" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>The order of implement layers is important. 

If no implement is declared, then the default main-implement is used. </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="extends" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>The order of multiple extends is important. </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:choice minOccurs="0" maxOccurs="unbounded">
                                <xs:element name="argument-transfer"/>
                            </xs:choice>
                            <xs:attribute name="on" type="xs:string" use="required"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="name" type="xs:string" use="required"/>
                <xs:attribute name="protocol" use="optional" default="cdecl">
                    <xs:simpleType>
                        <xs:restriction base="xs:token">
                            <xs:enumeration value="cdecl"/>
                            <xs:enumeration value="pascal"/>
                            <xs:enumeration value="fastcall"/>
                            <xs:enumeration value="naked"/>
                            <xs:enumeration value="thiscall"/>
                            <xs:enumeration value="poscall"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
                <xs:attributeGroup ref="ti:atg-symbol"/>
                <xs:attributeGroup ref="ti:atg-storage-traits"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:element name="function" type="ti:base-function">
        <xs:annotation>
            <xs:documentation>Declare a function</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="implement">
        <xs:annotation>
            <xs:documentation>Implement a layer of a function</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="ti:base-function-impl">
                    <xs:attribute name="name" type="xs:string" use="required"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!--========== DATA TYPE ==========-->
    <xs:attributeGroup name="atg-symbol">
        <xs:attribute name="access" use="optional" default="local">
            <xs:simpleType>
                <xs:union>
                    <xs:simpleType>
                        <xs:restriction base="xs:integer">
                            <xs:minInclusive value="-127"/>
                            <xs:maxInclusive value="127"/>
                        </xs:restriction>
                    </xs:simpleType>
                    <xs:simpleType>
                        <xs:restriction base="xs:token">
                            <xs:enumeration value="public"/>
                            <xs:enumeration value="protected"/>
                            <xs:enumeration value="private"/>
                            <xs:enumeration value="local"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:union>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="atg-storage-traits">
        <xs:attribute name="static" type="xs:boolean" use="optional" default="false"/>
        <xs:attribute name="constant" type="xs:boolean" use="optional" default="false"/>
        <xs:attribute name="transient" type="xs:boolean" use="optional" default="false"/>
        <xs:attribute name="storage" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="xs:integer">
                    <xs:simpleType>
                        <xs:restriction base="xs:token">
                            <xs:enumeration value="volatile"/>
                            <xs:enumeration value="register"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:union>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="share" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="xs:integer">
                    <xs:simpleType>
                        <xs:restriction base="xs:token">
                            <xs:enumeration value="global"/>
                            <xs:enumeration value="process"/>
                            <xs:enumeration value="thread"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:union>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="managed" type="xs:boolean" use="optional" default="false"/>
    </xs:attributeGroup>
    <xs:complexType name="base-type-use">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="specialize" type="ti:base-element"/>
            <xs:element name="construct" type="ti:base-operand"/>
        </xs:choice>
        <xs:attribute name="on" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:complexType name="base-type-def">
        <xs:complexContent>
            <xs:extension base="ti:base-code-unit">
                <xs:sequence>
                    <xs:element name="specializer" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>Entity element can't have any template parameters.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:choice>
                                <xs:element name="generic"/>
                                <xs:element name="type"/>
                            </xs:choice>
                        </xs:complexType>
                    </xs:element>
                    <xs:choice>
                        <xs:annotation>
                            <xs:documentation>Type Model</xs:documentation>
                        </xs:annotation>
                        <xs:element ref="ti:type"/>
                        <xs:element name="base">
                            <xs:complexType>
                                <xs:complexContent>
                                    <xs:extension base="ti:base-type-use">
                                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                                            <xs:element name="extends" type="ti:base-type-use">
                                                <xs:annotation>
                                                    <xs:documentation>parent::@base is just for copy (with public access and all private-elements kept), and extends are for inherit, multiple extends is allowed. </xs:documentation>
                                                </xs:annotation>
                                            </xs:element>
                                            <xs:element ref="ti:element"/>
                                            <xs:element name="union">
                                                <xs:complexType>
                                                    <xs:sequence>
                                                        <xs:element ref="ti:element" maxOccurs="unbounded"/>
                                                    </xs:sequence>
                                                </xs:complexType>
                                            </xs:element>
                                            <xs:element ref="ti:function"/>
                                        </xs:choice>
                                    </xs:extension>
                                </xs:complexContent>
                            </xs:complexType>
                        </xs:element>
                        <xs:element name="point-to" type="ti:base-type-def"/>
                        <xs:element name="refer-to" type="ti:base-type-def"/>
                        <xs:element name="array-of" type="ti:base-type-def"/>
                    </xs:choice>
                    <xs:element name="constructor" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>Specify how the type or element can be constructed. 
For element, type-construct is done before element-constructor. </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element name="parameter" minOccurs="0" maxOccurs="unbounded"/>
                                <xs:element name="initializer"/>
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                    <xs:element name="trait" minOccurs="0" maxOccurs="unbounded">
                        <xs:complexType>
                            <xs:attribute name="name" type="xs:string" use="required"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="name" type="xs:string" use="optional"/>
                <xs:attribute name="size" type="xs:integer" use="optional"/>
                <xs:attribute name="align" type="xs:integer" use="optional" default="1"/>
                <xs:attributeGroup ref="ti:atg-symbol"/>
                <xs:attributeGroup ref="ti:atg-storage-traits"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="base-element">
        <xs:complexContent>
            <xs:extension base="ti:base-type-def"/>
        </xs:complexContent>
    </xs:complexType>
    <xs:element name="type">
        <xs:annotation>
            <xs:documentation>Inner type</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="ti:base-type-def"/>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="element">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="ti:base-element"/>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:group name="grp-declare">
        <xs:annotation>
            <xs:documentation>typedef, function-proto</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="ti:function"/>
            <xs:element ref="ti:type"/>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-define">
        <xs:annotation>
            <xs:documentation>variable-def, function-def</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="ti:element"/>
        </xs:choice>
    </xs:group>
    <!--========== DATA VALUE ==========-->
    <xs:group name="grp-value">
        <xs:annotation>
            <xs:documentation>Value representation</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="number" type="xs:string"/>
            <xs:element name="string">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="lang" type="xs:language" use="optional"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="time">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:string">
                            <xs:attribute name="format" type="xs:string" use="optional" default="YYYY-MM-DD"/>
                            <xs:attribute name="timezone" type="xs:string" use="optional" default="+00:00"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="binary">
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:anySimpleType">
                            <xs:attribute name="encoding" type="xs:string" use="required"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="pointer"/>
            <xs:element name="reference"/>
            <xs:element name="expression" type="ti:base-expression"/>
            <xs:element name="array">
                <xs:complexType/>
            </xs:element>
        </xs:choice>
    </xs:group>
    <!--========== DEVELOP ==========-->
    <!--________________________________________________-->
    <!--STATEMENT - CONTROL-->
    <xs:group name="grp-control-symbol">
        <xs:annotation>
            <xs:documentation>control do-structure. 
A do-structure has: 
    I initialize
    S step
    C condition

label-attribute in control-symbol refers to target-label. </xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="control-goto" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>unconditionally goto. </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="control-break" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>break the do-structure</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="control-next" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>do the next-step, with C</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="control-previous" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>do the previous-step, with C</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="control-redo" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>re-do the current step, without C</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="control-reset" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>re-do the do-structure, with I-C</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="control-yield" type="ti:base-code-unit">
                <xs:annotation>
                    <xs:documentation>yield the current do-structure, with a returned yield-handle. </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:choice>
    </xs:group>
    <xs:complexType name="base-control">
        <xs:complexContent>
            <xs:extension base="ti:base-code-unit">
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:group ref="ti:grp-control-symbol"/>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:group name="grp-control">
        <xs:annotation>
            <xs:documentation>condition, loop, try-catch, fork</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="iterate">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-control">
                            <xs:attribute name="iterator" type="xs:string" use="optional"/>
                            <xs:attribute name="range" type="xs:string" use="optional"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="branch">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-control">
                            <xs:sequence>
                                <xs:element name="on" type="ti:base-expression" minOccurs="0"/>
                                <xs:element name="do"/>
                            </xs:sequence>
                            <xs:attribute name="on" type="xs:string" use="optional"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="branches">
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-control">
                            <xs:choice>
                                <xs:element name="branch"/>
                            </xs:choice>
                            <xs:attribute name="default" type="xs:string" use="optional"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="loop">
                <xs:annotation>
                    <xs:documentation>infinite-loop if both while and until aren't specified.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:complexContent>
                        <xs:extension base="ti:base-control">
                            <xs:sequence>
                                <xs:choice minOccurs="0">
                                    <xs:element name="while" type="ti:base-expression"/>
                                    <xs:element name="until" type="ti:base-expression"/>
                                </xs:choice>
                                <xs:element name="do"/>
                            </xs:sequence>
                            <xs:attribute name="while" type="xs:string" use="optional"/>
                            <xs:attribute name="until" type="xs:string" use="optional"/>
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="fork" type="ti:base-control"/>
            <xs:element ref="ti:do"/>
        </xs:choice>
    </xs:group>
    <xs:element name="do">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="ti:base-control">
                    <xs:choice>
                        <xs:element name="initialize"/>
                        <xs:element name="previous"/>
                        <xs:element name="next"/>
                        <xs:element name="check"/>
                        <xs:element name="catch"/>
                        <xs:element name="finalize"/>
                        <xs:element name="cleanup"/>
                    </xs:choice>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!--STATEMENT - GENERAL-->
    <!--========== STATEMENT GROUPS ==========-->
    <xs:group name="grp-any">
        <xs:choice>
            <xs:group ref="ti:grp-lexical"/>
            <xs:group ref="ti:grp-control"/>
            <xs:group ref="ti:grp-operator"/>
            <xs:group ref="ti:grp-function"/>
            <xs:group ref="ti:grp-declare"/>
            <xs:group ref="ti:grp-define"/>
            <xs:group ref="ti:grp-general"/>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-lexical">
        <xs:annotation>
            <xs:documentation>namespace</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="namespace" type="ti:st-namespace"/>
            <xs:element name="namespace-using" type="xs:string"/>
        </xs:choice>
    </xs:group>
    <xs:group name="grp-general">
        <xs:annotation>
            <xs:documentation>modulization, misc</xs:documentation>
        </xs:annotation>
        <xs:choice/>
    </xs:group>
    <!--STATEMENT - LEXICAL-->
    <xs:complexType name="st-namespace">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:group ref="ti:grp-any"/>
        </xs:choice>
        <xs:attribute name="name" type="xs:string" use="optional" default="global"/>
    </xs:complexType>
</xs:schema>
